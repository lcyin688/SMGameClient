{"version":3,"sources":["assets/c2f-framework/libs/rc4/RC4.ts"],"names":[],"mappings":";;;;;;;AAAA;;GAEG;AACH;IAKI,aAAY,GAAa;QACrB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;QACb,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACtB,CAAC;IAEO,qBAAO,GAAf,UAAgB,GAAa;QACzB,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;QAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC1B,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;SACZ;QAED,IAAI,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;QACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;YAEvC,OAAO;YACP,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACf,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;SACd;IACL,CAAC;IAEM,qBAAO,GAAd,UAAe,GAAG;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAClD,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;SACzB;IACL,CAAC;IAEM,qBAAO,GAAd,UAAe,GAAG;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAClD,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;SACzB;IACL,CAAC;IAEM,kBAAI,GAAX;QACI,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;QAChB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;QAC5B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;QAE/B,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACZ,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAEZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QAEZ,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IAClC,CAAC;IAAA,CAAC;IACN,UAAC;AAAD,CAvDA,AAuDC,IAAA;AAvDY,kBAAG","file":"","sourceRoot":"/","sourcesContent":["/**\n * RC4 stream cipher algorithm.\n */\nexport class RC4 {\n    _i: number;\n    _j: number;\n    _S: number[];\n\n    constructor(key: number[]) {\n        this._i = 0;\n        this._j = 0;\n        this._S = [];\n        this.initKey(key);\n    }\n\n    private initKey(key: number[]) {\n        let S = this._S;\n        for (let i = 0; i < 256; i++) {\n            S[i] = i;\n        }\n\n        let keyLen = key.length;\n        for (let i = 0, j = 0; i < 256; i++) {\n            j = (j + S[i] + key[i % keyLen]) % 256;\n\n            // Swap\n            let tmp = S[i];\n            S[i] = S[j];\n            S[j] = tmp;\n        }\n    }\n\n    public encrypt(buf) {\n        for (let i = 0, length = buf.length; i < length; i++) {\n            buf[i] ^= this.prga();\n        }\n    }\n\n    public decrypt(buf) {\n        for (let i = 0, length = buf.length; i < length; i++) {\n            buf[i] ^= this.prga();\n        }\n    }\n\n    public prga() {\n        let S = this._S;\n        let i = (this._i + 1) % 256;\n        let j = (this._j + S[i]) % 256;\n\n        let temp = S[i];\n        S[i] = S[j];\n        S[j] = temp;\n\n        this._i = i;\n        this._j = j;\n\n        return S[(S[i] + S[j]) % 256];\n    };\n}"]}