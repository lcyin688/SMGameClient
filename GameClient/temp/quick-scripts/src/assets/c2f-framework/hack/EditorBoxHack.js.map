{"version":3,"sources":["assets/c2f-framework/hack/EditorBoxHack.ts"],"names":[],"mappings":";;;;AAAA,oCAAoC;AACpC,mEAAmE;AACnE,IAAI,CAAC,UAAU,IAAI,EAAE,CAAC,GAAG,CAAC,QAAQ,KAAK,EAAE,CAAC,GAAG,CAAC,cAAc,EAAE;IAC1D,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,SAAS,CAAC,mBAAmB,GAAG;QACrD,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,UAAU,CAAC;YACP,IAAI,MAAM,CAAC,OAAO,GAAG,GAAG,EAAE;gBACtB,IAAI,OAAO,GAAe,IAAI,CAAC,SAAS,CAAC;gBACzC,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE;oBACzB,IAAI,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,qBAAqB,EAAE,CAAC;oBACpD,IAAI,YAAY,GAAG,QAAQ,CAAC,eAAe,CAAC,YAAY,IAAI,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC;oBACvF,IAAI,YAAY,GAAG,QAAQ,CAAC,eAAe,CAAC,YAAY,IAAI,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC;oBACvF,IAAI,KAAK,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC;oBAC7C,IAAI,iBAAiB,GAAG,YAAY,GAAG,YAAY,CAAC;oBACpD,IAAI,mBAAmB,GAAG,iBAAiB,GAAG,KAAK,CAAC;oBACpD,OAAO,CAAC,KAAK,CAAC,mBAAiB,YAAY,wBAAmB,YAAY,iBAAY,KAAO,CAAC,CAAC;oBAC/F,OAAO,CAAC,KAAK,CAAC,wBAAsB,iBAAiB,+BAA0B,mBAAqB,CAAC,CAAC;oBACtG,IAAI,QAAQ,CAAC,IAAI,IAAI,mBAAmB,EAAE;wBACtC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;wBACxB,OAAO;qBACV;oBAED,6BAA6B;oBAC7B,IAAI,QAAQ,GAAG,CAAC,mBAAmB,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;oBAC7D,MAAM,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;oBACrD,OAAO,CAAC,KAAK,CAAC,eAAa,QAAU,CAAC,CAAC;iBAC1C;qBAAM;oBACH,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;oBACrF,OAAO,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;iBACnC;aACJ;QACL,CAAC,EAAE,GAAG,CAAC,CAAC;IACZ,CAAC,CAAA;CACJ","file":"","sourceRoot":"/","sourcesContent":["// 基于CocosCreator2.x EditBox组件hack代码\n// 移动端web环境下，当EditBox会被弹出的软键盘遮挡时，视图向上滚动至EditBox在软键盘上方可见的位置。反之视图位置不变\nif (!CC_PREVIEW && cc.sys.platform === cc.sys.MOBILE_BROWSER) {\n    cc.EditBox[\"_ImplClass\"].prototype._adjustWindowScroll = function () {\n        let self = this;\n        setTimeout(function () {\n            if (window.scrollY < 100) {\n                let editBox: cc.EditBox = self._delegate;\n                if (editBox && editBox.node) {\n                    let worldBox = editBox.node.getBoundingBoxToWorld();\n                    let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;\n                    let clientHeight = document.documentElement.clientHeight || document.body.clientHeight;\n                    let ratio = cc.winSize.height / scrollHeight;\n                    let keyboardDomHeight = scrollHeight - clientHeight;\n                    let keyboardCocosHeight = keyboardDomHeight * ratio;\n                    console.error(`scrollHeight: ${scrollHeight}, clientHeight: ${clientHeight}, ratio: ${ratio}`);\n                    console.error(`keyboardDomHeight: ${keyboardDomHeight}, keyboardCocosHeight: ${keyboardCocosHeight}`);\n                    if (worldBox.yMin >= keyboardCocosHeight) {\n                        console.error(\"return\");\n                        return;\n                    }\n\n                    // DOM坐标系下，EditBox底部与软键盘顶部的距离\n                    let domDelta = (keyboardCocosHeight - worldBox.yMin) / ratio;\n                    window.scroll({ top: domDelta, behavior: 'smooth' });\n                    console.error(`domDelta: ${domDelta}`);\n                } else {\n                    self._elem.scrollIntoView({ block: \"start\", inline: \"nearest\", behavior: \"smooth\" });\n                    console.error(`scrollIntoView`);\n                }\n            }\n        }, 500);\n    }\n}"]}