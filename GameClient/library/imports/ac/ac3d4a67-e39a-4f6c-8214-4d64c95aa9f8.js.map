{"version":3,"sources":["assets/c2f-framework/component/ui/multiTexture/assembler/MultiAssembler.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["const gfx = cc[\"gfx\"];\nconst vfmtPosUvColorIndex = new gfx.VertexFormat([\n    { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },\n    { name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },\n    { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_UINT8, num: 4, normalize: true },\n    { name: \"a_texture_idx\", type: gfx.ATTR_TYPE_FLOAT32, num: 1 },\n]);\n\nexport default class MultiAssembler extends cc.Assembler {\n    /** 每个顶点的数据长度 */\n    protected floatsPerVert: number = 6;\n    protected verticesCount: number = 4;\n    protected indicesCount: number = 6;\n    protected uvOffset: number = 2;\n    protected colorOffset: number = 4;\n    protected textureIdxOffset: number = 5;\n\n    protected _renderData = null;\n    protected _local = [];\n\n    protected get verticesFloats() {\n        return this.verticesCount * this.floatsPerVert;\n    }\n\n    constructor() {\n        super();\n\n        this._renderData = new cc[\"RenderData\"]();\n        this._renderData.init(this);\n\n        this.initData();\n        this.initLocal();\n    }\n\n    public initData() {\n        let data = this._renderData;\n        // createFlexData支持创建指定格式的renderData\n        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());\n\n        // createFlexData不会填充顶点索引信息，手动补充一下\n        let indices = data.iDatas[0];\n        let count = indices.length / 6;\n        for (let i = 0, idx = 0; i < count; i++) {\n            let vertextID = i * 4;\n            indices[idx++] = vertextID;\n            indices[idx++] = vertextID + 1;\n            indices[idx++] = vertextID + 2;\n            indices[idx++] = vertextID + 1;\n            indices[idx++] = vertextID + 3;\n            indices[idx++] = vertextID + 2;\n        }\n    }\n\n    public initLocal() {\n        this._local = [];\n        this._local.length = 4;\n    }\n\n    public getBuffer(v) {\n        return cc.renderer[\"_handle\"].getBuffer(\"mesh\", this.getVfmt());\n    }\n\n    public getVfmt() {\n        return vfmtPosUvColorIndex;\n    }\n\n    public updateColor(comp, color?) {\n        if (CC_NATIVERENDERER) {\n            this[\"_dirtyPtr\"][0] |= cc.Assembler[\"FLAG_VERTICES_OPACITY_CHANGED\"];\n        }\n        let uintVerts = this._renderData.uintVDatas[0];\n        if (!uintVerts) return;\n        color = color != null ? color : comp.node.color._val;\n        let floatsPerVert = this.floatsPerVert;\n        let colorOffset = this.colorOffset;\n        for (let i = colorOffset, l = uintVerts.length; i < l; i += floatsPerVert) {\n            uintVerts[i] = color;\n        }\n    }\n\n    public updateTextureIdx(sprite) {\n        let verts = this._renderData.vDatas[0];\n\n        for (let i = 0; i < this.verticesCount; i++) {\n            let dstOffset = this.floatsPerVert * i + this.textureIdxOffset;\n            verts[dstOffset] = sprite.textureIdx;\n        }\n    }\n\n    public updateWorldVerts(comp) {\n        let local = this._local;\n        let verts = this._renderData.vDatas[0];\n\n        let matrix = comp.node._worldMatrix;\n        let matrixm = matrix.m,\n            a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5],\n            tx = matrixm[12], ty = matrixm[13];\n\n        let vl = local[0], vr = local[2],\n            vb = local[1], vt = local[3];\n\n        let floatsPerVert = this.floatsPerVert;\n        let vertexOffset = 0;\n        let justTranslate = a === 1 && b === 0 && c === 0 && d === 1;\n\n        if (CC_NATIVERENDERER) {\n            // left bottom\n            verts[vertexOffset] = vl;\n            verts[vertexOffset + 1] = vb;\n            vertexOffset += floatsPerVert;\n            // right bottom\n            verts[vertexOffset] = vr;\n            verts[vertexOffset + 1] = vb;\n            vertexOffset += floatsPerVert;\n            // left top\n            verts[vertexOffset] = vl;\n            verts[vertexOffset + 1] = vt;\n            vertexOffset += floatsPerVert;\n            // right top\n            verts[vertexOffset] = vr;\n            verts[vertexOffset + 1] = vt;\n        } else {\n            if (justTranslate) {\n                // left bottom\n                verts[vertexOffset] = vl + tx;\n                verts[vertexOffset + 1] = vb + ty;\n                vertexOffset += floatsPerVert;\n                // right bottom\n                verts[vertexOffset] = vr + tx;\n                verts[vertexOffset + 1] = vb + ty;\n                vertexOffset += floatsPerVert;\n                // left top\n                verts[vertexOffset] = vl + tx;\n                verts[vertexOffset + 1] = vt + ty;\n                vertexOffset += floatsPerVert;\n                // right top\n                verts[vertexOffset] = vr + tx;\n                verts[vertexOffset + 1] = vt + ty;\n            } else {\n                let al = a * vl, ar = a * vr,\n                    bl = b * vl, br = b * vr,\n                    cb = c * vb, ct = c * vt,\n                    db = d * vb, dt = d * vt;\n\n                // left bottom\n                verts[vertexOffset] = al + cb + tx;\n                verts[vertexOffset + 1] = bl + db + ty;\n                vertexOffset += floatsPerVert;\n                // right bottom\n                verts[vertexOffset] = ar + cb + tx;\n                verts[vertexOffset + 1] = br + db + ty;\n                vertexOffset += floatsPerVert;\n                // left top\n                verts[vertexOffset] = al + ct + tx;\n                verts[vertexOffset + 1] = bl + dt + ty;\n                vertexOffset += floatsPerVert;\n                // right top\n                verts[vertexOffset] = ar + ct + tx;\n                verts[vertexOffset + 1] = br + dt + ty;\n            }\n        }\n    }\n\n    public fillBuffers(comp, renderer) {\n        if (renderer.worldMatDirty) {\n            this.updateWorldVerts(comp);\n        }\n\n        let renderData = this._renderData;\n        let vData = renderData.vDatas[0];\n        let iData = renderData.iDatas[0];\n\n        let buffer = this.getBuffer(renderer);\n        let offsetInfo = buffer.request(this.verticesCount, this.indicesCount);\n\n        // buffer data may be realloc, need get reference after request.\n\n        // fill vertices\n        let vertexOffset = offsetInfo.byteOffset >> 2,\n            vbuf = buffer._vData;\n\n        if (vData.length + vertexOffset > vbuf.length) {\n            vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset);\n        } else {\n            vbuf.set(vData, vertexOffset);\n        }\n\n        // fill indices\n        let ibuf = buffer._iData,\n            indiceOffset = offsetInfo.indiceOffset,\n            vertexId = offsetInfo.vertexOffset;\n        for (let i = 0, l = iData.length; i < l; i++) {\n            ibuf[indiceOffset++] = vertexId + iData[i];\n        }\n    }\n\n    public packToDynamicAtlas(comp, frame) {\n        if (CC_TEST) return;\n\n        if (!frame._original && cc.dynamicAtlasManager && frame._texture.packable) {\n            let packedFrame: any = cc.dynamicAtlasManager.insertSpriteFrame(frame);\n            if (packedFrame) {\n                frame._setDynamicAtlasFrame(packedFrame);\n            }\n        }\n        let material = comp._materials[0];\n        if (!material) return;\n\n        if (material.getProperty(\"texture\") !== frame._texture._texture) {\n            // texture was packed to dynamic atlas, should update uvs\n            comp._vertsDirty = true;\n            comp._updateMaterial();\n        }\n    }\n}"]}