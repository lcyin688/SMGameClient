{"version":3,"sources":["assets/c2f-framework/mvvm/JsonOb.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["\n/**\n * 实现动态绑定的核心部分，\n * 每次修改属性值，都会调用对应函数，并且获取值的路径\n */\n\nconst OP = Object.prototype;\nconst types = {\n    obj: '[object Object]',\n    array: '[object Array]'\n}\nconst OAM = ['push', 'pop', 'shift', 'unshift', 'short', 'reverse', 'splice'];\n\n/**\n * 实现属性拦截的类\n */\nexport class JsonOb<T> {\n    constructor(obj: T, callback: (newVal: any, oldVal: any, pathArray: string[]) => void) {\n        if (OP.toString.call(obj) !== types.obj && OP.toString.call(obj) !== types.array) {\n            console.error('请传入一个对象或数组');\n        }\n        this._callback = callback;\n        this.observe(obj);\n    }\n\n    private _callback;\n    /**对象属性劫持 */\n    private observe<T>(obj: T, path?) {\n        if (OP.toString.call(obj) === types.array) {\n            this.overrideArrayProto(obj, path);\n        }\n        Object.keys(obj).forEach((key) => {\n            let self = this;\n            let oldVal = obj[key];\n            let pathArray = path && path.slice();\n            if (pathArray) {\n                pathArray.push(key);\n            }\n            else {\n                pathArray = [key];\n            }\n            Object.defineProperty(obj, key, {\n                get: function () {\n                    return oldVal;\n                },\n                set: function (newVal) {\n                    //cc.log(newVal);\n                    if (oldVal !== newVal) {\n                        if (OP.toString.call(newVal) === '[object Object]') {\n                            self.observe(newVal, pathArray);\n                        }\n                        self._callback(newVal, oldVal, pathArray)\n                        oldVal = newVal\n                    }\n                }\n            })\n\n            if (OP.toString.call(obj[key]) === types.obj || OP.toString.call(obj[key]) === types.array) {\n                this.observe(obj[key], pathArray)\n            }\n        }, this)\n    }\n\n    /**\n     * 对数组类型进行动态绑定\n     * @param array \n     * @param path \n     */\n    private overrideArrayProto(array: any, path) {\n        // 保存原始 Array 原型  \n        var originalProto = Array.prototype;\n        // 通过 Object.create 方法创建一个对象，该对象的原型是Array.prototype  \n        var overrideProto = Object.create(Array.prototype);\n        var self = this;\n        var result;\n\n        // 遍历要重写的数组方法  \n        OAM.forEach((method) => {\n            Object.defineProperty(overrideProto, method, {\n                value: function () {\n                    var oldVal = this.slice();\n                    //调用原始原型上的方法  \n                    result = originalProto[method].apply(this, arguments);\n                    //继续监听新数组  \n                    self.observe(this, path);\n                    self._callback(this, oldVal, path);\n                    return result;\n                }\n            })\n        });\n        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto  \n        array['__proto__'] = overrideProto;\n    }\n}"]}